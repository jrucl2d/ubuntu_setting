아래는 keyd(키-디) 매뉴얼 문서를 한국어로 번역한 내용입니다. 참고로 기술 용어 또는 원문 그대로 유지한 부분이 있을 수 있습니다.

---

## 이름

**keyd** – 키 재매핑 데몬

## 사용법

`keyd [command] [options]`

## 명령어

* `monitor [-t]`
  키 이벤트를 출력합니다. `-t` 옵션이 주어지면 마지막 이벤트로부터 흐른 시간(ms)도 출력됩니다. 키 이름이나 장치 ID를 알아낼 때, 디버깅할 때 유용합니다.

* `listen`
  실행 중인 keyd 데몬이 출력하는 레이어 상태 변화를 stdout으로 출력합니다. 스크립팅에 유용합니다.

* `bind reset| […]`
  주어진 바인딩(binding)들을 적용합니다. 바인딩에 대한 자세한 내용은 아래 “Bindings(바인딩)” 항목을 참고하세요.

* `reload`
  설정 파일들을 다시 불러옵니다.

* `list-keys`
  유효한 키 이름들을 나열합니다.

* `input [-t ] […]`
  주어진 텍스트를 입력장치로서 직접 보내는 기능입니다. 인자를 주지 않으면 STDIN에서 읽습니다. 옵션으로 마이크로초 단위의 타임아웃을 주어 각각의 이벤트 사이 간격을 조절할 수 있습니다.

* `do [-t ] […]`
  주어진 표현식을 실행합니다. 형식은 매크로(MACROS)를 참고하세요. 인자를 주지 않으면 STDIN에서 표현식을 읽습니다. 타임아웃(`_`)은 매크로 시퀀스 간의 시간초과(microseconds)를 나타냅니다.

* `check […]`
  설정 파일들을 검증합니다. 파일을 인자로 주지 않으면 설정 디렉토리 안의 모든 파일을 검증합니다. 유효성 검증에 실패한 파일이 있을 경우 비-0 종료코드를 반환합니다.

## 옵션

* `-v, --version`
  버전을 출력하고 종료합니다.
* `-h, --help`
  도움말을 출력하고 종료합니다.

## 설명

keyd는 시스템 전반에 걸쳐 키 재매핑을 수행하는 데몬으로, **레이어(layer)** 지원, **원샷(oneshot) 수정자(modifier)**, **매크로(macros)** 등의 기능을 제공합니다.
가장 기본적인 형태에서는 사용자 정의 키 배치(custom key layout)를 정의하여 디스플레이 서버(예: Wayland/X/TTY)를 넘어 지속시킬 수 있습니다. 프로그램은 포그라운드에서 실행되며 진단 정보를 표준 출력 스트림으로 출력합니다. init 시스템에 의해 단일 인스턴스로 실행되는 것이 의도되어 있습니다.

> **주의:** keyd가 주입된 설정이 잘못되면 입력 장치가 작동하지 않아 컴퓨터 사용이 불가능해질 수 있습니다.
> 이 경우 “++” 키 시퀀스가 강제 종료(panic) 시퀀스로 작동하여 keyd를 종료할 수 있습니다.

## 설정(Configuration)

설정 파일은 대략 INI 스타일 형식을 따릅니다. 즉, *[section_name]* 형식의 헤더와 그 뒤에 바인딩이 나옵니다. ‘#’로 시작하는 라인은 무시됩니다. 설정 파일은 `/etc/keyd/`에 저장되며 초기화 시 로드됩니다. `reload` 명령어로 동작 중인 설정을 갱신할 수 있습니다 (예: `sudo keyd reload`).
유효한 설정 파일은 확장자가 `.conf`이어야 하며, **반드시** `_[ids]_` 섹션으로 시작해야 합니다.
예시 형태:

```
[ids]
...
```

또는

```
[ids]
* - - ...
```

첫 번째 형태는 명시적으로 매칭될 ID 목록을 지정하고, 두 번째 형태는 명시적으로 제외되지 않은 **모든** ID에 매칭됩니다. 예를 들어:

```
[ids]
* -0123:4567
```

는 ID `0123:4567`인 장치를 **제외한 모든 키보드**에 적용됩니다.
반대로:

```
[ids]
0123:4567
```

는 정확히 해당 ID를 가진 장치에만 적용됩니다.
장치 ID는 `monitor` 명령으로 얻을 수 있습니다.
하나의 장치 ID는 한 개의 설정 파일에만 나올 수 있습니다.
각 파일의 이후 섹션은 레이어(layer)에 대응하며, `_ [global] _` 섹션은 별도입니다. 설정 오류는 로그 출력에 나타납니다 (예: `sudo journalctl -eu keyd`로 확인).
ID가 장치 타입(키보드/마우스) 기준으로 여러 개 매칭될 수 있는 경우, `k:` 접두사를 이용해 **키보드만 매칭**하거나, `m:` 접두사를 이용해 **마우스만 매칭**할 수 있습니다 (예: `m:046d:b01d`).

> 참고: 와일드카드(`*`)는 keyd가 키보드로 식별하는 장치만 매칭합니다.
> 또한 keyd는 **마우스 관리**도 가능하지만 (예: 클릭시 oneshot 수정자를 초기화), 마우스 ID는 명시적으로 나열해야 합니다. 마우스 지원은 현재 실험적이며 일부 터치패드 같은 장치에만 해당됩니다. 일부 마우스를 포함하면 포인터 동작에 문제를 일으킬 수 있습니다.
> 또한 마우스가 키보드로 잘못 식별되는 경우(마우스가 오작동한다면) 마우스를 **명시적으로 블랙리스트** 해야 할 수 있습니다.

---

## 레이어(Layers)

레이어는 바인딩(binding)들의 모음으로, 각 바인딩은 특정 키의 동작을 지정합니다. 여러 레이어가 동시에 활성화될 수 있으며, 활성화 순서대로 겹쳐져(keymap이 뒤덮이는) 작동합니다. 기본 레이어는 `main`이라고 불리며, 일반적인 바인딩은 여기에 정의됩니다.
예를 들어:

```
[main]
capslock = layer(nav)

[nav]
h = left
k = up
j = down
l = right
```

위 설정은 `capslock`을 누르고 있는 동안 `nav` 레이어가 `main` 레이어를 덮어쓰게 되어, `h/j/k/l` 키가 각각 화살표 방향 기능을 하게 됩니다.
keyd는 다른 대부분의 리매핑 도구들과 달리 수정자(modifier)에 대한 **일급 지원(first-class support)**을 제공합니다.
레이어 이름 끝에 “:모디파이어셋(modifiers)”을 붙여 **명시적 매핑이 없는 경우에 대리로 적용할 수정자(modifier)를 지정할 수 있습니다**. 레이어 이름은 최대 64자까지 허용됩니다. 예를 들어:

```
[main]
capslock = layer(capslock)

[capslock:C]
j = down
```

이 설정은 `capslock`이 `control` 역할을 하도록 만들되, `capslock+j` 조합에서는 `down`을 출력하도록 합니다.
즉, `capslock+j`는 **수정자 없는** `down`을 출력하고, `shift+capslock+j`는 **shift+down**으로 출력됩니다.
바인딩이 정의된 레이어의 모디파이어들은 그 바인딩에 영향을 주지 않는다는 점에 주의하세요.
레이어 헤더의 공식 형식:

```
"[" 레이어이름 (선택적":"모디파이어셋) "]"
```

모디파이어는 다음 중 하나일 수 있습니다:

* C = Control
* M = Meta/Super
* A = Alt
* S = Shift
* G = AltGr
  각 레이어 뒤에는 바인딩들이 이어지며, 바인딩 형식은 다음과 같습니다:

```
<키이름> = <동작> || <설명>
```

기본적으로 `main` 레이어 내에서는 각 키가 스스로(self) 바인딩 되어 있습니다. 다만 수정자 키들은 예외인데, 각각 해당 모디파이어에 대응하는 레이어에 바인딩되어 있습니다. 예:

```
control = layer(control)
meta = layer(meta)
shift = layer(shift)
leftalt = layer(alt)
rightalt = layer(altgr)
```

이로 인해 수정자 키를 오버라이드(overriding)하는 것이 단순해집니다. 예컨대:

```
[ids]
*
[control]
j = down
```

는 `control+j`를 누르면 `down`이 출력되도록 합니다.

만약 동일한 키에 대해 여러 바인딩이 존재하면 **가장 최근 정의된 것이 우선**됩니다. 같은 레이어 헤더가 여러 번 나타나면 해당 레이어는 각 헤더에 정의된 바인딩들의 합이 됩니다. 단, 레이어 타입(modifier 셋 등)은 재할당할 수 없습니다.

---

## 복합 레이어(Composite Layers)

`+`로 구분된 기존 레이어들을 조합해 새로운 레이어를 정의할 수 있습니다. 이 복합 레이어는 그 구성원 전체가 활성화될 때만 유효하며, 수정자 붙은 형태는 허용되지 않고 명시적으로 할당(assign)될 수 없습니다. 예:

```
[control+alt]
h = left
```

위 설정은 `control+alt+h`로 눌렀을 때 `left`를 출력합니다. 다만 `control+alt+f1` 등 명시되지 않은 키는 수정자가 붙은 원래 동작이 유지됩니다.
또한, 복합 레이어는 **구성 레이어들보다 뒤에 정의되어야** 합니다. 즉:

```
[layer1]
[layer2]
[layer1+layer2]
```

순이어야 하고,

```
[layer1+layer2]
[layer1]
[layer2]
```

순서는 잘못된 예입니다.

---

## 레이아웃(Layouts)

레이아웃은 알파벳 키(alpha keys)를 변경하기 위한 특수 레이어입니다. 레이어와 달리, 레이아웃은 모디파이어(modifier)를 가질 수 없으며 동시에 한 개만 활성화됩니다. 기본 레이아웃은 `main`입니다. 레이아웃 변경은 `setlayout()` 동작으로 가능합니다. keyd는 편의상 여러 일반적인 문자 레이아웃들을 `/usr/share/keyd/layouts` 디렉토리에 포함하고 있습니다.
비영어(non-English) 레이아웃의 경우 별도의 shift 레이어를 포함하고 있어 포함 순서(order)가 중요하고, keyd의 compose 정의(유니코드 지원)를 사용해야 할 수 있습니다. 예:

```
# 포함: colemak 레이아웃
include layouts/colemak

[global]
default_layout = mylayout

[mylayout:layout]
a = b
b = c
# 기타…
[control]
1 = setlayout(customlayout)
2 = setlayout(colemak)
```

이처럼 레이아웃을 설정할 수 있습니다.

---

## 코드 입력(Chording)

코드(chord)는 동시에 눌려야 할 키들의 조합을 하나의 단위로 처리합니다. `+`로 구분된 키 이름들을 왼쪽에 두고, 그 조합이 **지정된 간격(기본 50ms)** 내에 눌렸을 때 대응하는 동작이 실행됩니다. 예:

```
j+k = esc
```

위 설정은 `j`와 `k`가 동시에 눌리면 `esc`를 출력합니다.
기본 chording 간격(50ms)은 키보드 물리적 특성에 따라 조정할 수 있습니다.

---

## 유니코드(Unicode) 지원

만약 keyd가 **유효한 UTF-8 시퀀스**를 오른쪽 값으로 만나면, 이를 keyd-특유의 XKB 시퀀스로 매핑하려 시도합니다. 이를 위해서는 keyd에 동봉된 compose 파일(`/usr/share/keyd/keyd.compose`)이 사용 가능해야 합니다. 사용 방법:

```
ln -s /usr/share/keyd/keyd.compose ~/.XCompose
```

또한 디스플레이 서버에서는 **기본 US 레이아웃**이 설정되어 있어야 합니다. 비영어 레이아웃 사용자는 충돌 방지를 위해 keyd 내에서 레이아웃을 설정하는 것이 권장됩니다.

> 참고: GTK4에는 대형 XCompose 파일이 있을 경우 충돌을 일으키는 버그가 있습니다.

---

## 별칭(Aliases)

각 키는 선택적으로 *별칭(alias)*을 지정할 수 있습니다. 별칭은 키 이름 대신 유효한 왼쪽 값으로 사용될 수 있습니다. 한 키에 여러 키가 동일한 별칭을 가질 수 있지만, 한 키가 동시에 여러 별칭을 갖는 것은 불가능합니다. 예컨대 기본적으로 `leftmeta`와 `rightmeta`는 별칭 `meta`에 바인딩되어 있습니다.
별칭은 `[aliases]` 섹션에서 정의됩니다.
예:

```
[aliases]
meta = leftmeta
alt = rightalt
```

별칭이 유효한 키 이름인 경우 해당 키코드가 기본으로 할당됩니다.

---

## 파일 포함(File Inclusion)

설정 파일 내에서 `include 파일경로` 키워드를 사용해 같은 디렉토리 내의 다른 파일을 포함할 수 있습니다. 이 구문은 `[ids]` 섹션 이후 어느 위치에나 나타날 수 있습니다. 포함된 파일의 내용은 마치 해당 위치에 삽입된 것처럼 동작합니다.
경로는 `/etc/keyd/` 또는 `/usr/share/keyd/` 디렉토리 하위여야 합니다.
예:

```
/etc/keyd/default.conf:
[ids]
*
include common
[main]
capslock = layer(capslock)
[capslock]
1 = setlayout(colemak)
2 = setlayout(dvorak)

/etc/keyd/common:
[main]
rightmeta = layer(nav)
[nav]
h = left
j = down
k = up
l = right

/usr/share/keyd/layouts/dvorak:
a = a
s = o
...
```

제한사항:

* 모든 `include` 문은 `[ids]` 섹션 이후 위치해야 합니다.
* 포함된 파일에는 `[ids]` 섹션이 없어야 합니다.
* 포함된 파일은 다른 파일을 `include`해서는 안 됩니다 (비재귀적 포함).

---

## 글로벌(Global) 설정

설정 파일에서 `[global]` 섹션을 정의할 수 있으며, 여기에는 다음 옵션들을 포함할 수 있습니다:

* `macro_timeout:` 매크로 시퀀스 처음 실행과 첫 반복 사이의 시간(밀리초). 기본값: 600.
* `macro_repeat_timeout:` 반복 매크로 사이의 시간(밀리초). 기본값: 50.
* `layer_indicator:` 설정 시, 레이어가 활성화될 때 CapsLock LED를 켭니다. 일부 Wayland 컴포지터에서는 LED 제어가 적극적으로 수행되어 이 옵션이 작동하지 않을 수 있습니다. 기본값: 0.
* `macro_sequence_timeout:` 매크로 시퀀스 내에서 각 키가 출력되기 전 마이크로초 단위로 타임아웃을 추가합니다. 일부 시스템에서 입력 버퍼 오버플로우를 막기 위해 유용합니다.
* `chord_timeout:` 코드(chord)로 인식할 수 있는 연속 키 간 최대 시간(기본값: 50ms).
* `chord_hold_timeout:` 코드로 인식되기 위해 최소한으로 키가 눌려야 하는 시간(기본값: 0).
* `oneshot_timeout:` 0이 아니면, oneshot 레이어 활성화 후 지정된 밀리초 이후 타임아웃됩니다(기본값: 0).
* `disable_modifier_guard:` 기본적으로 keyd는 프로그램이 추가 수정자를 보지 않게끔 필요한 경우 제어 키 입력을 주입(modifier guard)합니다(예: Firefox에서 alt 키만 눌렀을 때 문제가 생기는 것을 방지). 이 옵션을 켜면 해당 동작이 비활성화 됩니다(기본값: 0).
* `overload_tap_timeout:` 0이 아니면 오버로드(overloaded)된 키가 지정된 밀리초 이상 눌렸을 경우 탭(tap) 동작을 무시합니다(기본값: 0).

> 참고: 유니코드 문자와 키 시퀀스는 매크로로 처리되며, 따라서 관련 타임아웃 옵션의 영향을 받습니다.

---

## 매크로(MACROS)

여러 keyd 동작들이 매크로 표현식을 인자로 받을 수 있습니다. 매크로 표현식의 형태는 다음 중 하나입니다:

* `macro()`
* `[[-...-]-...]`

여기서 `_…_`는 유효한 유니코드 문자이고, `_…_`은 다음 형태입니다:

```
[…] 
```

각 토큰(token)은 다음 중 하나입니다:

* 유효한 키 코드
* 타입2 매크로
* 연속된 유니코드 문자 그룹
* `+`로 구분된 키 코드 그룹(동시에 눌림)
* `ms` 단위 시간이 포함된 타임아웃(여기서 값 < 1024)
  예시:
* `C-a`
* `macro(C-a)`
* `macro(leftcontrol+leftmeta)` → 왼쪽 Meta와 왼쪽 Control 키를 동시에 탭
* `A-M-x`
* `macro(Hello space World)`
* `macro(h e l l o space w o r ld)` (위 예와 동일)
* `macro(C-t 100ms google.com enter)`
  작은 토큰으로 쪼개면 이스케이프 메커니즘으로 작동합니다:
  `macro(space)`는 공백을 삽입하지만 `macro(s pace)`는 “space” 문자열을 출력합니다.
  또한 `macro(3+5)`는 3과 5 키를 동시에 눌러야 하고, `macro(3 + 5)`는 “3+5”를 타이핑합니다.

> 유니코드 문자를 사용하기 위해선 위 “Unicode Support” 항목의 전제조건이 필요합니다.

---

## 동작(ACTIONS)

키는 선택적으로 하나 이상의 인자를 받는 동작(action)에 바인딩할 수 있습니다. 주요 동작들:

* `layer(<레이어>)`
  해당 키를 누르고 있는 동안 지정된 레이어를 활성화합니다.
* `oneshot(<레이어>)`
  키를 탭(tap)했을 경우, 다음 키 눌림 동안 지정된 레이어를 활성화합니다.
* `swap(<레이어>)`
  현재 활성 레이어와 지정된 레이어를 스왑(swap)합니다. 만약 현재 레이어가 토글 상태라면 비활성화되고 지정 레이어가 토글됩니다. 그렇지 않으면 현재 레이어 비활성화되고 지정 레이어가 해당 키가 눌려 있는 동안 활성화됩니다. 복합 레이어(composite layer)에 대해 이 동작의 동작은 정의되어 있지 않습니다.
  예:

  ```
  [control]
  x = swap(xlayer)
  [xlayer]
  s = C-s
  b = S-insert
  ```

  이 기능은 복잡한 설정을 할 때 필요할 수 있습니다.
* `setlayout(<레이아웃>)`
  현재 레이아웃을 지정된 레이아웃으로 변경합니다.
* `clear()`
  토글되거나 oneshot된 레이어를 모두 해제합니다.
* `toggle(<레이어>)`
  지정된 레이어를 영구적으로 토글(켜거나 끔)합니다.
* `layerm(<레이어>, <매크로>)`
  `layer()`와 동일하지만 레이어 변경 전에 지정된 매크로를 실행합니다.
* `oneshotm(<레이어>, <매크로>)`
  `oneshot()`과 동일하지만 레이어 변경 전에 매크로를 실행합니다.
* `oneshotk(<레이어>, <매크로>)`
  `oneshot()`과 동일하지만 키가 눌려 있는 동안 해당 키 자체 기능도 유지됩니다. 주로 바로 이어지는 문자 키의 동작을 일시적으로 변경할 때 유용합니다.
* `swapm(<레이어>, <매크로>)`
  `swap()`과 동일하지만 레이어 변경 직후 매크로를 실행합니다.
* `togglem(<레이어>, <매크로>)`
  `toggle()`과 동일하지만 레이어 토글 전에 매크로를 실행합니다.
* `clearm(<매크로>)`
  `clear()`와 동일하지만 레이어 해제 전에 매크로를 실행합니다.
* `repeat()`
  마지막 키 또는 매크로 시퀀스를 반복 실행합니다.

---

## 키 오버로딩(Key Overloading)

* `overload(<레이어>, <동작>)`
  키가 눌려있는 동안 지정된 레이어를 활성화하고, 탭했을 경우 지정된 동작을 실행합니다.
* `overloadt(<레이어>, <동작>, <밀리초>)`
  `overload`와 비슷하지만, 지정된 밀리초 이상 키를 눌렀을 때만 레이어를 활성화합니다. 주로 문자 키(letter keys)를 오버로드할 때 유용합니다. 다만 이 방식은 타이핑 시 시각적 지연이 발생할 수 있습니다.
* `overloadt2(<레이어>, <동작>, <밀리초>)`
  `overloadt`와 동일하지만 키 탭이 개입(intervening)되면 hold 상태로 해석됩니다.
* `overloadi(<레이어>, <동작>, <밀리초>)`
  최근에 non-action(즉 기호가 아닌) 키가 눌린 시점으로부터 지정 밀리초보다 짧으면 한 동작(예: 문자 입력)을 하고, 그렇지 않으면 레이어를 활성화하는 방식입니다. 문자 키 오버로드(homerow mods)와 특히 유용합니다.
  예:

```
a = overloadi(a, overloadt2(control, a, 200), 150)
```

위 설정은 다음과 같은 동작을 합니다:

* 만약 _a_가 직전 non-action 키 눌림으로부터 150ms 내라면 그냥 ‘a’를 출력합니다.
* 그렇지 않고 150ms 이상 경과했지만 200ms 미만 동안 눌렀고 탭 사이에 다른 키가 개입되지 않았다면 `control` 레이어로 동작합니다.
  이 방식은 타이핑 중에는 바로 ‘a’를 출력하면서도, 길게 누르면 레이어 트리거로 작동하도록 하는 방법입니다.
  이런 사용 사례가 흔하므로 `lettermod(<키>, <레이어>, <동작>, <밀리초>)`라는 매크로가 별도로 정의되어 있습니다.
* `timeout(<키>, <밀리초>, <동작>)`
  지정된 밀리초 동안 키 이벤트가 없으면 `<동작>`을 실행합니다. 예:

  ```
  timeout(a, 500, layer(control))
  ```

  위 설정은 `a` 키가 눌리고 500ms 동안 다른 키가 눌리지 않으면 `control` 레이어로 동작하게 합니다.

> 참고: 이는 오래된 옵션이며 미묘한 부작용이 있으므로 대부분의 사용자는 오버로드 함수(overload) 중 하나를 사용하는 것이 좋습니다.

* `macro2(<timeout>, <repeat_timeout>, <매크로표현식>)`
  지정된 timeout과 repeat_timeout을 갖는 매크로를 생성합니다. timeout에 0을 주면 반복이 비활성화됩니다. 예:

  ```
  macro2(400, 50, macro(Hello space World))
  macro2(120, 80, left)
  ```

* `command(<쉘명령>)`
  지정된 셸 명령을 실행합니다. 예:

  ```
  command(brightness down)
  ```

  > 주의: 이 명령은 keyd 프로세스를 실행한 사용자가 권한을 갖기 때문에(root일 가능성) 신중히 사용해야 합니다.

* `noop`
  아무 동작도 하지 않습니다.

---

## IPC (프로세스 간 통신)

keyd는 클라이언트-서버 모델을 채택하고 있으며, `-e` 옵션을 통해 접근할 수 있습니다. 이를 통해 키맵(keymap)을 **실행 중(runtime)** 에도 수정할 수 있습니다. 예를 들어, 사용자가 다른 프로그램으로 전환할 때 스크립트를 통해 키맵을 변경하는 것이 가능합니다. `keyd-application-mapper(1)`이라는 응용 프로그램-매핑 도구가 함께 제공됩니다.

> 참고: 키맵 소켓에 접근할 수 있는 사용자는 ‘전체 시스템에 대한 권한’을 갖는 것으로 간주되어야 합니다.

---

## 바인딩(Bindings)

`bind` 명령은 하나 이상의 바인딩을 인자로 받습니다. 각 바인딩은 다음 형식을 따라야 합니다:

```
[<레이어>] <키이름> = <동작> || <설명>
```

여기서 `<레이어>`는 키가 바인딩될 레이어 이름이며, 생략 가능(가장 최근 활성 키보드에 적용)합니다.
특별한 경우로 문자열 `"reset"`을 바인딩으로 사용하면 현재 키맵이 원래 상태로 되돌아가고(동적 적용된 바인딩이 모두 제거됨) 바인딩들이 다시 적용됩니다. 예:

```
$ keyd bind '- = C-c'
$ keyd bind reset '+ = C-c'
```

위 예에서는 먼저 `-` 키에 `Ctrl-c` 바인딩을 적용하고, 다음에는 `+` 키에 적용하기 전에 `reset`을 통해 기존 바인딩을 제거하고 새 바인딩을 적용하고 있습니다.
기본적으로 바인딩 표현식은 가장 최근 활성된 키보드에 적용됩니다.

---

## 예제(Examples)

### 예제 1

`esc+q`를 눌렀을 때 dvorak 레이아웃이 토글되게 만듭니다.

```
[ids]
*
[main]
esc = layer(esc)
[dvorak]
a = a
s = o
...
[esc]
q = toggle(dvorak)
```

### 예제 2

Shift 키 동작을 뒤집되(modifier 동작을 망가뜨리지 않고) 일반 키 매핑을 수행합니다.

```
[ids]
*
[main]
1 = !
2 = @
3 = #
4 = $
5 = %
6 = ^
7 = &
8 = *
9 = (
0 = )
[shift]
0 = 0
1 = 1
2 = 2
3 = 3
4 = 4
5 = 5
6 = 6
7 = 7
8 = 8
9 = 9
```

### 예제 3

Control 키를 한 번 탭하면 다음 키에 적용하고, 두 번 탭하면 토글되어 다시 누를 때까지 적용되고, 길게 누르면 정상적으로 작동하도록 만듭니다.

```
[main]
control = oneshot(control)

[control]
control = toggle(control)
```

### 예제 4

Meta 키는 정상적으로 작동하다가 `\`` 키가 눌린 후에는 alt_tab 레이어가 활성화됩니다. 그 후에는 `leftmeta`키 누를 때`Alt+Tab`이 출력됩니다(원래 `Meta+`` 조합).

```
[meta]
` = swap(alt_tab, A-tab)

[alt_tab:A]
tab = A-S-tab
` = A-tab
```

### 예제 5

Compose 키 기능을 사용해 국제 문자를 생성합니다. 이 기능이 동작하려면 디스플레이 서버에서 `setxkbmap -option compose:menu` 등이 실행되어 있어야 합니다.

```
[main]
rightalt = layer(dia)
[dia]
o = macro(compose o ")
e = macro(compose c =)
```

위 설정은 `o`를 `ö`로, `e`를 `€`로 매핑합니다.

### 예제 6

양쪽 Shift 키를 탭하면 CapsLock이 활성화되도록 합니다.

```
[shift]
leftshift = capslock
rightshift = capslock
```

### 예제 7

CapsLock 키는 Control로 작동하되, `h/j/k/l`와 함께 사용될 경우 화살표 키로 작동하게 합니다. 탭했을 때는 Escape로 작동합니다.

```
[main]
capslock = overload(capslock, esc)
esc = capslock

[capslock:C]
h = left
k = up
j = down
l = right
```

### 예제 8

Esc 키와 End 키를 비활성화합니다.

```
[main]
esc = noop
end = noop
```

---

## 주의사항(Notes)

keyd가 가상 입력장치를 생성하므로, `setxkbmap`, `xset` 같은 상위 수준 입력 도구로 설정한 내용이 keyd가 (재)시작될 때 사라질 수 있습니다. 관련 내용은 이슈 트래커에서 확인할 수 있습니다.

## 환경변수(Environment Variables)

* `KEYD_DEBUG` : 디버그 로그 레벨을 설정합니다. 0,1,2 중 하나를 지정할 수 있으며 기본값은 0입니다.

## 저자

작성자: Raheman Vaiya (2017-)

## 버그

버그 제보나 기능 요청은 다음 URL에서 해주세요: (생략)

---

필요하시면 특정 설정 항목(예: 레이어, 오버로드, 유니코드 지원 등)을 더 깊이 설명해드릴 수 있고, 예제 설정을 한국어 키보드/한국 레이아웃에 맞춰 변환해드릴 수도 있습니다. 그렇게 할까요?
